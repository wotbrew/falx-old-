(ns falx.db
  "A mini datomic like memory store with indexing, integrity checking etc."
  (:require [falx.util :refer :all]))

(def default-id (bigdec 0))

(defn next-id
  "Return the next-id that will be used if you create a new entity"
  [m]
  (::id m default-id))

(defn- inc-id
  "Increments the id and returns the db"
  [m]
  (update m ::id (fnil inc default-id)))

(defn- rem-eav
  [m id attr]
  (dissoc-in m [::eav id attr]))

(defn- set-eav
  [m id attr value]
  (assoc-in m [::eav id attr] value))

(def set-disj (fnil disj #{}))

(defn rem-ae
  [m id attr]
  (update-in m [::ae attr] set-disj id))

(defn- set-ae
  [m id attr]
  (update-in m [::aev attr] set-conj id))

(defn rem-ave
  [m id attr value]
  (update-in m [::ave attr value] set-disj id))

(defn- set-ave
  [m id attr value]
  (update-in m [::ave attr value] id))

(defn- index
  [m id attr value]
  (cond->
   (set-eav m id attr value)
   (get (::ae? m) attr) (set-ae id attr)
   (get (::ave? m) attr) (set-ave id attr value)))

(defn- unindex
  [m id attr value]
  (cond->
   (rem-eav m id attr)
   (get (::ae? m) attr) (rem-ae id attr)
   (get (::ave? m) attr) (rem-ave id attr value)))

(defn valid?
  "Verify the attribute via any integrity checks setup for the db"
  [m id attr value]
  (let [rules (::integrity m)]
    (or (empty? rules)
        (some #(% m id attr value) rules))))

(defn set-attr
  "Set the attribute to the given value. Verifies validity via integrity constraints."
  [m id attr value]
  (if (valid? m id attr value)
    (index m id attr value)
    m))

(defn rem-attr
  "Removes the attribute from the entity."
  [m id attr]
  (let [val (-> m ::eav (get id) (get attr))]
    (unindex m id attr val)))

(defn attr
  "Returns the value for the attribute on entity given by `id`.
   Defaulting to `else` the attribute does not exist."
  ([m id attr else]
     (-> m ::eav (get id) (get attr else)))
  ([m id attr]
     (falx.db/attr m id attr nil)))

